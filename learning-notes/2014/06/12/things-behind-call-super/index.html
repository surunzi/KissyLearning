<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Base类继承中的callSuper实现</title><link rel="stylesheet" href="http://surunzi.github.io/KissyLearning/css/style.css"><link rel="shortcut icon" href="http://surunzi.github.io/KissyLearning/favicon.ico"></head><body><div id="nav"><ul class="container"><li><a href="http://surunzi.github.io/KissyLearning/">首页</a></li><li><a href="http://surunzi.github.io/KissyLearning/tutorial/">教程</a></li><li><a href="http://surunzi.github.io/KissyLearning/example/">示例</a></li><li><a href="http://surunzi.github.io/KissyLearning/api/">API</a></li><li><a href="http://surunzi.github.io/KissyLearning/tool/">工具</a></li><li><a href="http://surunzi.github.io/KissyLearning/document/">文档</a></li><li><a href="http://gallery.kissyui.com/">组件</a></li><li><a href="http://docs.kissyui.com/">官网</a></li><li><a href="https://github.com/kissyteam/kissy">GitHub</a></li><li><a href="http://surunzi.github.io/KissyLearning/feed.xml">RSS</a></li></ul></div><div id="page" data-feature="prettify"></div><div id="post" class="container"><div class="article"><h2 class="title">Base类继承中的callSuper实现</h2><p>刚接触到Kissy的Base模块时就很好奇它的callSuper方法到底是怎样实现的，这东西实在是太方便了。首先简述一下callSuper的作用：假设现在对象o有方法a，在方法a内调用callSuper。callSuper将找到o的原型op，并调用op中的方法a。</p><p>可惜，在callSuper里面能够访问到的只有调用该方法a的对象和调用callSuper的方法。调用方法a的对象不一定是o，因为有可能o其实是该对象的原型链上的一个原型。那么，该怎么做呢？</p><p>attribute/src/attribute.js:</p><pre><code>callSuper: function () {
        var method, obj,
            self = this,
            args = arguments;
        // 如果调用callSuper的对象本身就是function
        if (typeof self === 'function' &amp;&amp; self.__name__) {
            method = self;
            obj = args[0];
            args = Array.prototype.slice.call(args, 1);
        } else {
            method = arguments.callee.caller;
            if (method.__wrapped__) {
                method = method.caller;
            }
            obj = self;
        }
        var name = method.__name__;
        if (!name) {
            return undefined;
        }
        var member = method.__owner__.superclass[name];
        if (!member) {
            return undefined;
        }
        return member.apply(obj, args || []);
    }
</code></pre><p>从callSuper的源代码可以知道，callSuper首先获取到调用它的函数method和其函数名name。然后再通过method.__owner__获取到其所在的类构造方法，之后在通过该类构造方法的superclass得到method所在对象的原型，最后再调用原型中的同名方法。当然，方法中的__name__和__owner__等属性都是在用extend方法创建类时就添加上去的。</p><p>PS：本站停更。考完分布式计算还有嵌入式课程设计答完辩后再回来继续更=_=</p></div><div id="post-disqus-container"><div id="disqus_thread"></div></div></div><div id="footer" class="container"><div class="inner"><span class="copyright">&copy; Kissy Learning 2014</span></div></div><script src="http://surunzi.github.io/KissyLearning/js/kissy/seed.js"></script><script src="http://surunzi.github.io/KissyLearning/js/KissyLearning.js"></script></body></html><script type="text/javascript">var disqus_shortname = 'kissylearning';
var disqus_url = 'http://surunzi.github.io/KissyLearning/learning-notes/2014/06/12/things-behind-call-super/';
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script src="http://surunzi.github.io/KissyLearning/js/prettify/prettify.js"></script>