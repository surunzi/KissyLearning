<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Your awesome title</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</description>
    <link>http://surunzi.github.io/KissyLearning/</link>
    <atom:link href="http://surunzi.github.io/KissyLearning/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Kissy快速入门</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是模块化？&lt;/h3&gt;

&lt;p&gt;Kissy使用模块化开发，简单来说，就是将Kissy划分成多个部分，每个部分包含若干相似的功能。在开发过程中，需要用到哪一部分功能就需要载入相应的模块。需要进行DOM操作，就载入dom或者node模块；需要进行ajax操作，就载入io模块；需要进行cookie操作，就载入cookie模块，依此类推。&lt;/p&gt;

&lt;h3 id=&quot;kissy&quot;&gt;载入Kissy库&lt;/h3&gt;

&lt;p&gt;在使用Kissy库之前，必须将Kissy引入到你的页面中去，只需要在HTML页面中插入以下代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/kissy/k/1.4.3/seed.js&quot; data-config=&quot;{combine:true}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;seed.js文件只是一个模块加载器，并没有包含所有的Kissy文件。当你需要用到某些模块时，该加载器会动态加载所需要的文件。因此，如果是本地调试，不能单独将seed.js文件下载下来，必须下载整个Kissy库，当前最新的1.4.3版可戳&lt;a href=&quot;https://github.com/kissyteam/kissy/archive/v1.4.3.zip&quot;&gt;此处&lt;/a&gt;下载。&lt;/p&gt;

&lt;h3 id=&quot;kissyuse&quot;&gt;Kissy.use&lt;/h3&gt;

&lt;p&gt;在Kissy中加载各模块使用use方法，该方法挂载在Kissy对象上：&lt;strong&gt;KISSY.use(name,sandbox)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其中name为数组，指明需要使用的模块，sandbox为匿名函数，第一个参数为S，传入KISSY全局对象，其他参数依次带入所载入的模块返回的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.use([&#39;node&#39;, &#39;io&#39;], function (S, Node, io) {
    var ele = Node.one(&#39;#ele&#39;);
    ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;学习资料&lt;/h3&gt;

&lt;p&gt;进一步学习可前往：&lt;a href=&quot;http://surunzi.github.io/KissyLearning/tutorial/&quot;&gt;教程&lt;/a&gt;、&lt;a href=&quot;http://docs.kissyui.com/&quot;&gt;官网&lt;/a&gt;、&lt;a href=&quot;http://surunzi.github.io/KissyLearning/document/&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果有好的关于Kissy的学习资料，请发送邮件给我：&lt;strong&gt;surunzi1992@gmail.com&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/12/quick-start/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/12/quick-start/</guid>
      </item>
    
      <item>
        <title>使用requirejs的define方法来添加模块</title>
        <description>&lt;p&gt;记得之前在Kissy的官网上，有人建议将依赖模块的声明放到前面去，这样看起来会比较方便些。官网提供的解决方法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.add(function(S, require){
    var A = require(&#39;a&#39;);
    var B = require(&#39;b&#39;);
    var C = require(&#39;c&#39;);
    // Your code...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果觉得对这种解决方法不满意的话，我们也可以自行解决，方法就是在KISSY.add方法上再套上一层将参数位置颠倒，比如下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (S) {
    window.define = S.define = function (deps, callback) {
        var slice = Array.prototype.slice;
            
        if (arguments.length === 1) {
            S.add(deps);
            return;
        }
        
        S.add(function () {
            return callback.apply(null, slice.apply(arguments, [1]));
        }, {
            requires: deps
        });
    }
})(KISSY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将这段代码紧贴在Kissy库后面，就可以用requireJs的方法来添加模块了，比如下面：&lt;/p&gt;

&lt;p&gt;module-A.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;node&#39;, &#39;base&#39;], function (Node, Base) {
    ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function () {
    ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这段代码很粗糙，并没有做太多处理，你可以根据自己的实际需要再对其进行定制修改。。&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/09/use-requirejs-style-to-add-module/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/09/use-requirejs-style-to-add-module/</guid>
      </item>
    
      <item>
        <title>使用Base模块实现类的创建和继承</title>
        <description>&lt;p&gt;大型JavaScript应用程序除了需要将程序进行拆分模块化之外，通常也是免不了要使用&lt;strong&gt;类&lt;/strong&gt;这种在其它多数编程语言中极为常用的结构体，这其中要以Java，C#最为典型。JavaScript中并没有真正的类，但我们仍可以通过构造函数和new运算符来模拟出传统的类，并利用它来更好地组织代码结构，提高其可维护性。&lt;/p&gt;

&lt;p&gt;假设我们现在要实现一个Circle类，它继承于Geometry类。在不借助任何外部库的时候，最常见的写法通常是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Geometry(x, y) {
    this.x = x;
    this.y = y;
    ...
}
Geometry.prototype.render = function () {
    ...
}
function Circle(x, y, r) {
    Geometry.apply(this, [x, y]);
    this.r = r;
}
Circle.prototype = new Geometry();
Circle.prototype.getRadius = function () {
    ...
}
var c = new Circle(10, 10, 5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细看下，就会发觉这样子的写法其实存在着不少问题。其中最明显的一点就是不直观，试问下如果有一堆这样的代码，你能一眼就看出类与类之间的关系吗？为了让类的创建和继承更加简便化，不少类库都提供了不错的解决方案。以Kissy为例，我们可以使用Base模块很容易地来实现类的创建和继承。&lt;/p&gt;

&lt;p&gt;首先创建Geometry类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Geometry = Base.extend({
    // 在这里添加类的方法
    // 构造函数（可选）
    constructor: function (x, y) {
    ...
    },
    // 初始化函数，类创建后执行
    initializer: function () {
        ...
    },
    addStyle: function () {
        ...
    },
    render: function (canvas) {
        ...
    }
}, {
    // 这里是类名（可选）
    name: &#39;Geometry&#39;,
    // 类的属性，可使用默认的set和get方法，也可以自定义
    ATTRS: {
        // 在这里添加类的属性
        x: {
            value: 0,
            setter: function () {},
            getter: function () {}
        },
        y: {
            value: 0
        }
        ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来创建Circle类继承Geometry类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Circle = Geometry.extend({
    // 可以直接覆盖父类中的同名函数
    addStyle: function () {
        // 使用callSuper访问父类中的方法
        this.callSuper();
        ...
    },
    render: function (canvas) {
        ...
    }
}, {
    name: &#39;Circle&#39;,
    ATTRS: {
        r: {
            value: 0
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下创建类的步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果不继承任何类，则调用Base.extend({方法}, {属性})创建类&lt;/li&gt;
  &lt;li&gt;如果是继承已有类，则调用类名.extend({方法}, {属性})创建类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上就是Base模块实现类创建和继承的最基础的使用方法，更多详细信息请查看&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/tutorials/kissy/base/index.html&quot;&gt;官方教程&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;完整的示例和源码请戳&lt;a href=&quot;http://surunzi.github.io/KissyLearning/example/class/&quot;&gt;此处&lt;/a&gt;和&lt;a href=&quot;https://github.com/surunzi/KissyLearning/tree/master/example/class/&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 08 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/08/class-inheritance/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/08/class-inheritance/</guid>
      </item>
    
      <item>
        <title>Loader模块add方法源码一览</title>
        <description>&lt;p&gt;Kissy框架的模块加载器中最重要的就是add和use方法：add用于添加模块，use用于加载并使用模块。本文只介绍关于add方法的大概内部实现流程，use将在往后的学习笔记中介绍。&lt;/p&gt;

&lt;p&gt;稍微了解过Kissy的话都应该知道，Kissy使用use方法加载外部模块时将发起http请求模块所在的js文件，而模块文件内均有一个add方法。js文件加载完毕之后便会执行该add方法。那么，add方法究竟做了什么呢？&lt;/p&gt;

&lt;p&gt;loader/src/loader.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (S) {
    var Loader = S.Loader,
        ComboLoader = Loader.ComboLoader;
    Utils.mix(S, {
        add: function (name, factory, cfg) {
            ComboLoader.add(name, factory, cfg, arguments.length);
        }
    });
})(KISSY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将loader.js中必要的文件删除后，可以看到Kissy.add其实只是在ComboLoader.add之上做了一层封装。&lt;/p&gt;

&lt;p&gt;loader/src/combo-loader.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (S, undefined) {
    var Loader = S.Loader,
        addModule = Utils.addModule;
    ...
    function ComboLoader(callback) {
        ...
    }
    ...
    ComboLoader.add = function (name, factory, config, argsLen) {
        // KISSY.add(&#39;xx&#39;,[],function(){});
        if (argsLen === 3 &amp;amp;&amp;amp; Utils.isArray(factory)) {
            ...
        }
        // KISSY.add(function(){}), KISSY.add(&#39;a&#39;), KISSY.add(function(){},{requires:[]})
        if (typeof name === &#39;function&#39; || argsLen === 1) {
            ...
            addModule(name, factory, config);
        } else {
            ...
            addModule(name, factory, config);
        }
    };
    ...
    Loader.ComboLoader = ComboLoader;
})(KISSY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ComboLoader.add主要是对传入的参数进行了一些顺序处理，以适应不同的参数传递，最终调用的是Utils.addModule。&lt;/p&gt;

&lt;p&gt;loader/src/utils.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (S) {
    var Loader = S.Loader,
        Env = S.Env,
        mods = Env.mods;
    ...
    mix(Utils, {
        ...
        createModule: function (name, cfg) {
            var module = mods[name];
            ...
            mods[name] = module = new Loader.Module(mix({
                name: name
            }, cfg));
            return module;
        },
        addModule: function (name, factory, config) {
            ...
            Utils.createModule(name, mix({
                name: name,
                status: Loader.Status.LOADED,
                factory: factory
            }, config));
        }
    });
})(KISSY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utils.addModule检测模块是否已被加载过后调用Utils.createModule。Utils.createModule最终创建Loader.Module实例并最终赋值到Kissy.Env.modes[name]中去。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Loader.Module构造函数在loader/src/data-structure.js中&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 07 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/learning-notes/2014/06/07/inside-the-add-method-of-kissy-loader/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/learning-notes/2014/06/07/inside-the-add-method-of-kissy-loader/</guid>
      </item>
    
      <item>
        <title>Kissy模块加载器基础用法</title>
        <description>&lt;p&gt;Javascript模块化可以为我们带来代码复用、提高可维护性、按需加载文件等好处。目前比较流行的模块加载器有RequireJs和SeaJs。如果你正在使用Kissy库的话，就无需另外再去引入这些加载器，因为Kissy本身就是一个模块化的Javascript框架。本文将从一个实例出发说明Kissy模块化的基本使用方法，最终的效果可戳&lt;a href=&quot;http://surunzi.github.io/KissyLearning/example/module/&quot;&gt;此处&lt;/a&gt;进行查看。你也可以戳&lt;a href=&quot;https://github.com/surunzi/KissyLearning/tree/master/example/module/&quot;&gt;此处&lt;/a&gt;查看所有的源代码。&lt;/p&gt;

&lt;p&gt;首先建立HTML文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;title&quot;&amp;gt;
        &amp;lt;h1&amp;gt;模块按需加载&amp;lt;/h1&amp;gt;
        &amp;lt;span&amp;gt;请点击下面的按钮并同时查看网络请求情况&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;btn-wrapper&quot;&amp;gt;
        &amp;lt;div id=&quot;btn&quot;&amp;gt;点我加载模块并执行&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;http://g.tbcdn.cn/kissy/k/1.4.3/seed.js&quot; data-combine=&quot;{combine:true}&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;effect.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kissy中添加模块的步骤如下：&lt;/p&gt;

&lt;p&gt;1.新建一个js文件，在其中添加如下的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.add(function (S, Node) {
    /* 模块代码 */
    return;
    /* 最后可以返回结果供调用该模块的文件使用 */
}, {
    requires: [&#39;node&#39;] /* 可以加载多个该模块所依赖的模块，与函数的参数一一对应*/
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如我们这次例子的结构是以下这样的：&lt;/p&gt;

&lt;p&gt;snow.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.add(function (S, Node) {
    /* 变量定义 */
    var ...;
    // 初始化
    function init() {
    }
    // 开始执行动画
    function begin() {
    }
    // 绘制
    function draw() {
    }
    // 粒子构造函数
    function Particle() {
    }
    // 停止动画
    function stop() {
    }
    /* 将begin和stop方法返回供调用该模块的文件使用 */
    return {
        begin: begin,
        stop: stop
    };
}, {
    requires: [&#39;node&#39;]
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.配置包&lt;/p&gt;

&lt;p&gt;由于我们使用的是淘宝CDN，如果不注册包的话发送文件请求是会以淘宝CDN的地址为前缀，所以必须注册包用来映射正确的URL地址。同时包也在指明请求合并中起作用，这里不属于本文讨论范围就不详谈了。&lt;/p&gt;

&lt;p&gt;以这次为例子:&lt;/p&gt;

&lt;p&gt;effect.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.config(&#39;packages&#39;, {
    &#39;myModule&#39;: {
        base: window.location.href.replace(&#39;index.html&#39;, &#39;&#39;),
        ignorePackageNameInUri: true
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中base为包的url映射，可以把它当成单纯的字符串替换，例如：&lt;/p&gt;

&lt;p&gt;指明要使用’myModule/snow’这个包，它会将myModule替换为base, 请求地址为：base + ‘snow.js’；&lt;/p&gt;

&lt;p&gt;假如没有指定ignorePackageNameInUri为true，则请求地址为：base + ‘myModule/’ + ‘snow.js’。&lt;/p&gt;

&lt;p&gt;3.使用模块&lt;/p&gt;

&lt;p&gt;使用自定义模块就跟使用Kissy自带的模块一样简单，比如：&lt;/p&gt;

&lt;p&gt;effect.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.ready(function (S) {
KISSY.use(&#39;node&#39;, function (S, Node) {
    Node.one(&#39;#btn&#39;).on(&#39;click&#39;, function () {
        /* 点击按钮时加载snow模块并执行 */
        KISSY.use(&#39;myModule/snow&#39;, function (S, snow) {
            snow.begin();
        });
    });
});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，总结一下创建自定义模块的步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建文件，并用KISSY.add创建模块&lt;/li&gt;
  &lt;li&gt;如果有必要，注册模块所在包&lt;/li&gt;
  &lt;li&gt;用KISSY.use加载使用模块&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多关于Kissy Loader的信息请戳&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/guideline/kmd.html&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/tutorials/kissy/loader/index.html&quot;&gt;这里&lt;/a&gt;^_^&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 06 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/06/basic-module-loader-usage/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/basic-tutorial/2014/06/06/basic-module-loader-usage/</guid>
      </item>
    
      <item>
        <title>jQuery用户快速上手Kissy</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;1. 引入库文件&lt;/h3&gt;

&lt;p&gt;jQuery:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kissy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/kissy/k/1.4.3/seed.js&quot; data-config=&quot;{combine:true}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kissy跟jQuery一样，可以将其下载到本地进行使用，但更推荐使用淘宝的CDN。除能够减小服务器带宽压力，利用CDN加快js文件的载入速度外，还能直接使用combo，减少请求数，免去了让自己服务器支持combo功能的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 开始使用&lt;/h3&gt;

&lt;p&gt;jQuery:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {
    /* jQuery代码 */
});
// 或者
$(function () {
    /* jQuery代码 */ 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kissy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.use([&#39;node&#39;], function (S) {
S.ready(function (S) {
    var $ = S.all;
    /** jQuery风格代码 */
});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Dom操作上面基本上可以当成jQuery来进行使用，但还存在些许不同，之后有时间会单独整理一篇文章列出其中的不同点，当然也可以先参考&lt;a href=&quot;http://cyj.me/jquery-kissy-rosetta/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果想要使用ajax功能的话，可以写成下面的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.use([&#39;node&#39;, &#39;io&#39;], function (S) {
S.ready(function (S) {
    var $ = S.all,
        io = S.io,
        $.get = io.get,
        $.post = io.post;
    /** jQuery风格代码 */
});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后说一点，本文只是用一种抖机灵的方式让使用jQuery的人能像用jQuery一样来使用Kissy，还是强烈建议去查看下Kissy的&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/guideline/kmd.html&quot;&gt;模块化规范&lt;/a&gt;。毕竟，模块化才是Kissy相比于jQuery真正所具有的优势，至少在我看来是这样的。使用Kissy，你可以很方便地创建和管理自己的模块，得到类似使用requireJs管理模块依赖库所带来的好处，让开发过程变得更加简单高效，代码的可维护性更高。&lt;/p&gt;
</description>
        <pubDate>Fri, 30 May 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/basic-tutorial/2014/05/30/tutorial-for-jquery-user/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/basic-tutorial/2014/05/30/tutorial-for-jquery-user/</guid>
      </item>
    
      <item>
        <title>初窥Kissy源码结构</title>
        <description>&lt;p&gt;之前花了点时间大概看了下Kissy的官网部分文档，大致上也了解了Kissy的基本使用方法。当然，学东西的时候光看不练是很难真正将其掌握的。因此，也就有了这个放置在GitHub上的&lt;a href=&quot;https://github.com/surunzi/KissyLearning&quot;&gt;KissyLearning&lt;/a&gt;项目。考虑到网络上Kissy教程文档的缺乏，这里除了会发学习笔记外，可能还会发点傻瓜级教程什么的~_~&lt;/p&gt;

&lt;p&gt;点击&lt;a href=&quot;https://github.com/kissyteam/kissy&quot;&gt;此处&lt;/a&gt;查看Kissy项目的GitHub主页，其中src目录存放的就是Kissy的源码。从Build目录下可以打开seed.js（种子文件），可以看到包含了loader，features，ua三个基本模块。其中，loader（模块加载器）是Kissy的最开始部分。首先打开src/loader/目录下的build.xml文件，由最底部的代码得知，loader文件的合并顺序。&lt;/p&gt;

&lt;p&gt;Kissy/src/loader/build.xml：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;target name=&quot;concat&quot;&amp;gt;
    &amp;lt;concat destfile=&quot;${component.src.dir.tmp}/loader-pkg-debug.js&quot;
            encoding=&quot;${charset}&quot; outputencoding=&quot;${charset}&quot;&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/kissy.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/utils.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/data-structure.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/css-onload.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/get-script.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/configs.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/combo-loader.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/loader.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/i18n.js&quot;/&amp;gt;
        &amp;lt;path location=&quot;${component.src.dir}/init.js&quot;/&amp;gt;
    &amp;lt;/concat&amp;gt;
&amp;lt;/target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先来看kissy.js文件，把大部分代码删除掉，可以看到其基本结构下面这样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var KISSY = (function (undefined) {
    var S;
    S = {
        /** Some code here. */
    };
    return S;
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该文件定义一个KISSY的变量，作为整个库文件的最外层文件（命名空间），以免污染全局。其值是某自执行函数的返回值，即函数中所定义的S。该文件主要定义了全局命名空间，并定义了一小部分属性，诸如版本号，配置，日志等。&lt;/p&gt;

&lt;p&gt;接下来执行的是utils.js，data-structure.js…loader.js等文件，其基本结构大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (S) {
    /** Some code here. */
})(KISSY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用自执行函数，将KISSY对象传入函数中，并将操作后需要保留的值或方法赋给S，即KISSY对象。&lt;/p&gt;

&lt;p&gt;在基本的加载器初始完成之后，便可以使用模块加载器来进行模块的添加和管理了，之后代码的基本结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KISSY.add(function (S, require, exports, module) {
    /** Some code here. */
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于Kissy的模块定义规范可戳&lt;a href=&quot;http://docs.kissyui.com/1.4/docs/html/guideline/kmd.html&quot;&gt;此处&lt;/a&gt;查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;晚上大概扫了一下源码，就只了解了这么多，之后有空再细看。复习，不对。。是预习嵌入式去，祝自己下周考个好成绩。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;说笑的，求不挂就行(T＿T)&lt;/p&gt;
</description>
        <pubDate>Thu, 29 May 2014 00:00:00 +0800</pubDate>
        <link>http://surunzi.github.io/KissyLearning/learning-notes/2014/05/29/kissy-source-first-impression/</link>
        <guid isPermaLink="true">http://surunzi.github.io/KissyLearning/learning-notes/2014/05/29/kissy-source-first-impression/</guid>
      </item>
    
  </channel>
</rss>
